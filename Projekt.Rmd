---
title: 'Analityk kredytowy w Dream Housing Finance Company'
author: "Martyna Szypuła, Katarzyna Wójcik, Bartosz Zawora????"
output:
html_document:
  df_print: paged
  keep_md: true
  self_contained: true
---
--------------------------------------------

## Wyższa Szkoła Informatyki i Zarządzania z siedzibą w Rzeszowie


<table>
  <tr>
    <td>Imię i Nazwisko: </td>
    <td style="padding-right: 20px;">Martyna Szypuła</td>
    <td style="padding-right: 20px;">Katarzyna Wójcik</td>
    <td style="padding-right: 20px;">Bartosz Zawora???</td>
  </tr>
  <tr>
    <td>Numer albumu: </td>
    <td>69852</td>
    <td>70855</td>
    <td>11111</td>
  </tr>
  <tr>
    <td style="padding-right: 20px;">Rok, semestr, kierunek studiów: </td>
    <td>4 IIZ/2023/IZ</td>
  </tr>
  <tr>
    <td>Rok akademicki: </td>
    <td>2024/2025</td>
  </tr>
  <tr>
    <td>Nazwa przedmiotu: </td>
    <td>Drążenie danych</td>
  </tr>
  <tr>
    <td>Prowadzący: </td>
    <td>dr Sebastian Wójcik</td>
  </tr>
</table>

--------------------------------------------

## Opis sytuacji

Dream Housing Finance Company oferuje wszelkiego rodzaju pożyczki i kredyty. Obecne są na wszystkich obszarach miejskich, pół miejskich i wiejskich. Klient najpierw aplikuje o pożyczkę bądź kredyt, a następnie analityk kredytowy podejmuje ostateczną decyzją o przyznaniu klientowi pożyczki.
Firma chce zautomatyzować proces przyznawania pożyczek (w czasie rzeczywistym) na podstawie szczegółów klienta dostarczonych podczas wypełniania formularza aplikacyjnego online. Te szczegóły to płeć, stan cywilny, edukacja, liczba osób pozostających na utrzymaniu, dochód, kwota pożyczki, historia kredytowa i inne. Aby zautomatyzować ten proces, dostarczyli zestaw danych o dotychczasowych decyzjach przyznania i odrzucenia wniosku kredytowego dla ponad 600 klientów. Potrzebują, aby przeanalizować dane i przygotować raport jak poszczególne zmienne wpływają na decyzję kredytową.

--------------------------------------------

## Biblioteki
```{r warning = FALSE, message = FALSE}
#Instalowanie
# options(repos = c(CRAN = "https://cloud.r-project.org"))
# install.packages(c("readr", "knitr", "kableExtra", "dplyr", "e1071", "ggplot2"), dependencies = TRUE)

#Importowanie
library(readr)
library(knitr)
library(kableExtra)
library(dplyr)
library(e1071)
library(ggplot2)
```


## Dane

Plik CSV zawierający dane o klientach z nadanym statusem przyznania bądź nie pożyczki 'Loan_Status'

```{r warning=FALSE, message = FALSE}
loan_data <- read_delim("train.csv", delim = ";",
  escape_double = FALSE, col_types = cols(Dependents = col_number(),
  LoanAmount = col_double()), trim_ws = TRUE)
```


```{r warning=FALSE, message = FALSE}
loan_data %>% 
  knitr::kable(col.names = gsub("[_]", " ", names(loan_data)), align = 'c', digits = 2, format.args = list(big.mark = ",")) %>% 
  scroll_box(width = "100%", height = "300px") %>% 
  kable_styling(bootstrap_options = c("striped", "responsive"), full_width = FALSE, position = "left", fixed_thead = TRUE)
```

--------------------------------------------
### Zadanie 1

Scharakteryzuj zmienne ApplicantIncome, CoapplicantIncome, LoanAmount w zakresie: minimum, pierwszy kwartyl, medina, średnia, trzeci kwartyl, maksimum, odchylenie standardowe, wybrana miarę asymetrii i koncentracji w każdej z grup: według płci (Gender) i według stanu cywilnego (Married).

#### Według płci


```{r warning = FALSE, message = FALSE}
# ApplicantIncome
loan_data %>% dplyr::group_by(Gender) %>% dplyr::summarise(
  Minimum = min(ApplicantIncome, na.rm = TRUE),
  Q1 = quantile(ApplicantIncome, probs = 0.25, na.rm = TRUE),
  Mediana = median(ApplicantIncome, na.rm = TRUE),
  Srednia = mean(ApplicantIncome, na.rm = TRUE),
  Q3 = quantile(ApplicantIncome, probs = 0.75, na_rm = TRUE),
  Maksimum = max(ApplicantIncome, na.rm = TRUE),
  Odchylenie = sd(ApplicantIncome, na.rm = TRUE),
  Asymetria_TMC = e1071::skewness(ApplicantIncome, na.rm = TRUE), # Jawne wywołanie
  Kurtoza = e1071::kurtosis(ApplicantIncome, na.rm = TRUE)        # Jawne wywołanie
) %>%
  knitr::kable(caption = 'ApplicantIncome (według płci)', align = 'c', digits = 2, format.args = list(big.mark = ",")) %>%
  kable_styling(bootstrap_options = c("striped", "responsive"), full_width = FALSE, position = "left")

# CoapplicantIncome
loan_data %>% dplyr::group_by(Gender) %>% dplyr::summarise(
  Minimum = min(CoapplicantIncome, na.rm = TRUE),
  Q1 = quantile(CoapplicantIncome, probs = 0.25, na.rm = TRUE),
  Mediana = median(CoapplicantIncome, na.rm = TRUE),
  Srednia = mean(CoapplicantIncome, na.rm = TRUE),
  Q3 = quantile(CoapplicantIncome, probs = 0.75, na.rm = TRUE),
  Maksimum = max(CoapplicantIncome, na.rm = TRUE),
  Odchylenie = sd(CoapplicantIncome, na.rm = TRUE),
  Asymetria_TMC = e1071::skewness(CoapplicantIncome, na.rm = TRUE),
  Kurtoza = e1071::kurtosis(CoapplicantIncome, na.rm = TRUE)
) %>%
  knitr::kable(caption = 'CoapplicantIncome (według płci)', align = 'c', digits = 2, format.args = list(big.mark = ",")) %>%
  kable_styling(bootstrap_options = c("striped", "responsive"), full_width = FALSE, position = "left")

# LoanAmount
loan_data %>% dplyr::group_by(Gender) %>% dplyr::summarise(
  Minimum = min(LoanAmount, na.rm = TRUE),
  Q1 = quantile(LoanAmount, probs = 0.25, na.rm = TRUE),
  Mediana = median(LoanAmount, na.rm = TRUE),
  Srednia = mean(LoanAmount, na.rm = TRUE),
  Q3 = quantile(LoanAmount, probs = 0.75, na.rm = TRUE),
  Maksimum = max(LoanAmount, na.rm = TRUE),
  Odchylenie = sd(LoanAmount, na.rm = TRUE),
  Asymetria_TMC = e1071::skewness(LoanAmount, na.rm = TRUE),
  Kurtoza = e1071::kurtosis(LoanAmount, na.rm = TRUE)
) %>%
  knitr::kable(caption = 'LoanAmount (według płci)', align = 'c', digits = 2, format.args = list(big.mark = ",")) %>%
  kable_styling(bootstrap_options = c("striped", "responsive"), full_width = FALSE, position = "left")

```

#### Według stanu cywilnego

```{r warning = FALSE, message = FALSE}
# Wcześniej był filter(is.na(Married) == FALSE) - po imputacji nie ma potrzeby
# ApplicantIncome
loan_data %>% dplyr::group_by(Married) %>% dplyr::summarise(
  Minimum = min(ApplicantIncome, na.rm = TRUE),
  Q1 = quantile(ApplicantIncome, probs = 0.25, na.rm = TRUE),
  Mediana = median(ApplicantIncome, na.rm = TRUE),
  Srednia = mean(ApplicantIncome, na.rm = TRUE),
  Q3 = quantile(ApplicantIncome, probs = 0.75, na.rm = TRUE),
  Maksimum = max(ApplicantIncome, na.rm = TRUE),
  Odchylenie = sd(ApplicantIncome, na.rm = TRUE),
  Asymetria_TMC = e1071::skewness(ApplicantIncome, na.rm = TRUE),
  Kurtoza = e1071::kurtosis(ApplicantIncome, na.rm = TRUE)
) %>%
  knitr::kable(caption = 'ApplicantIncome (według stanu cywilnego)', align = 'c', digits = 2, format.args = list(big.mark = ",")) %>%
  kable_styling(bootstrap_options = c("striped", "responsive"), full_width = FALSE, position = "left")

# CoapplicantIncome
loan_data %>% dplyr::group_by(Married) %>% dplyr::summarise(
  Minimum = min(CoapplicantIncome, na.rm = TRUE),
  Q1 = quantile(CoapplicantIncome, probs = 0.25, na.rm = TRUE),
  Mediana = median(CoapplicantIncome, na.rm = TRUE),
  Srednia = mean(CoapplicantIncome, na.rm = TRUE),
  Q3 = quantile(CoapplicantIncome, probs = 0.75, na.rm = TRUE),
  Maksimum = max(CoapplicantIncome, na.rm = TRUE),
  Odchylenie = sd(CoapplicantIncome, na.rm = TRUE),
  Asymetria_TMC = e1071::skewness(CoapplicantIncome, na.rm = TRUE),
  Kurtoza = e1071::kurtosis(CoapplicantIncome, na.rm = TRUE)
) %>%
  knitr::kable(caption = 'CoapplicantIncome (według stanu cywilnego)', align = 'c', digits = 2, format.args = list(big.mark = ",")) %>%
  kable_styling(bootstrap_options = c("striped", "responsive"), full_width = FALSE, position = "left")

# LoanAmount
loan_data %>% dplyr::group_by(Married) %>% dplyr::summarise(
  Minimum = min(LoanAmount, na.rm = TRUE),
  Q1 = quantile(LoanAmount, probs = 0.25, na.rm = TRUE),
  Mediana = median(LoanAmount, na.rm = TRUE),
  Srednia = mean(LoanAmount, na.rm = TRUE),
  Q3 = quantile(LoanAmount, probs = 0.75, na.rm = TRUE),
  Maksimum = max(LoanAmount, na.rm = TRUE),
  Odchylenie = sd(LoanAmount, na.rm = TRUE),
  Asymetria_TMC = e1071::skewness(LoanAmount, na.rm = TRUE),
  Kurtoza = e1071::kurtosis(LoanAmount, na.rm = TRUE)
) %>%
  knitr::kable(caption = 'LoanAmount (według stanu cywilnego)', align = 'c', digits = 2, format.args = list(big.mark = ",")) %>%
  kable_styling(bootstrap_options = c("striped", "responsive"), full_width = FALSE, position = "left")

```
### zad 2
Oblicz jak często pożyczkę dostawały osoby Married=Y a jak często osoby Married=N. (tabela liczności). 

```{r warning = FALSE, message = FALSE}
cat("### Częstość przyznawania pożyczek według stanu cywilnego (Married) ###\n")
loan_status_married_df <- loan_data %>%
  dplyr::group_by(Married, Loan_Status) %>%
  dplyr::summarise(Liczba = n(), .groups = 'drop') %>% # Dodano .groups = 'drop' dla czystszego wyniku
  dplyr::ungroup() %>%
  dplyr::group_by(Married) %>%
  dplyr::mutate(Procent = Liczba / sum(Liczba) * 100)

loan_status_married_df %>%
  knitr::kable(
    caption = 'Częstość przyznawania pożyczek według stanu cywilnego',
    align = 'c',
    digits = 2,
    format.args = list(big.mark = ",") # Formatowanie liczb
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "responsive"),
    full_width = FALSE,
    position = "left"
  )
```
### zadanie 3
Oblicz jak często pożyczkę dostawały osoby Self_employed=Y a jak często osoby Self_employed=N. (tabela liczności). 
```{r warning = FALSE, message = FALSE}
cat("### Częstość przyznawania pożyczek według statusu zatrudnienia (Self_Employed) ###\n")
loan_status_self_employed <- data %>%
  dplyr::group_by(Self_Employed, Loan_Status) %>%
  dplyr::summarise(Liczba = n(), .groups = 'drop') %>% # Dodano .groups = 'drop' dla czystszego wyniku
  dplyr::ungroup() %>%
  dplyr::group_by(Self_Employed) %>%
  dplyr::mutate(Procent = Liczba / sum(Liczba) * 100)

loan_status_self_employed %>%
  knitr::kable(
    caption = 'Częstość przyznawania pożyczek według statusu zatrudnienia',
    align = 'c',
    digits = 2,
    format.args = list(big.mark = ",") # Formatowanie liczb
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "responsive"),
    full_width = FALSE,
    position = "left"
  )
loan_status_self_employed
```

### Zadanie 4
Dla wybranych zmiennych zrób wykres ramka-wąsy (boxplot). Niech zmienna Gender będzie tworzyła serie. Dodał tytuł, opis osi, legendę.

```{r warning = FALSE, message = FALSE}
ggplot(data = loan_data,
       mapping = aes(x = ApplicantIncome, y = LoanAmount, color = Gender),
       na_rm = TRUE
       ) +
  geom_boxplot(mapping = aes(color = Gender)) +
  labs(
    title = "Zależność LoanAmount od ApplicantIncome",
    subtitle = "w podziale na płeć",
    x = "Applicant Income",
    y = "Loan Amount",
    color = "Gender"
  ) +
  theme_minimal()

ggplot(data = loan_data,
       mapping = aes(x = CoapplicantIncome, y = LoanAmount, color = Gender),
       na_rm = TRUE
       ) +
  geom_boxplot(mapping = aes(color = Gender)) +
  labs(
    title = "Zależność LoanAmount od CoapplicantIncome",
    subtitle = "w podziale na płeć",
    x = "Coapplicant Income",
    y = "Loan Amount",
    color = "Gender"
  ) +
  theme_minimal()

```
### Zadanie 5
 Dla wybranych zmiennych zrób wykres ramka-wąsy (boxplot). Niech zmienna Married będzie tworzyła serie. Dodał tytuł, opis osi, legendę.
 
#### Wykres ramka-wąsy dla LoanAmount z podziałem na Gender
```{r warning = FALSE, message = FALSE}
ggplot(data = loan_data,
       aes(x = Married, y = ApplicantIncome, fill = Married)) +
  geom_boxplot() +
  labs(title = "Rozkład Dochodu Wnioskodawcy według Stanu Cywilnego",
       x = "Stan Cywilny",
       y = "Dochód Wnioskodawcy",
       fill = "Stan Cywilny") +
  theme_minimal()

```
### Zadanie 6
 Dla pary zmiennych ApplicantIncome, CoapplicantIncome zrób wykres rozrzutu. Niech zmienna Self_employed będzie tworzyła serie. Dodał tytuł, opis osi, legendę.
 
 ```{r warning = FALSE, message = FALSE}
scatterplot_income_self_employed <- data %>%
  ggplot(aes(x = ApplicantIncome, y = CoapplicantIncome, color = Self_Employed)) +
  geom_point(alpha = 0.6) + 
  labs(
    title = "Zależność między dochodem wnioskodawcy a dochodem współwnioskodawcy według statusu zatrudnienia",
    x = "Dochód wnioskodawcy",
    y = "Dochód współwnioskodawcy",
    color = "Samozatrudniony" 
  ) +
  theme_minimal() 
```
### Zadanie 7
Dla pary zmiennych ApplicantIncome, CoapplicantIncome zrób wykres rozrzutu. Niech zmienna Self_employed będzie tworzyła serie. Dodał tytuł, opis osi, legendę.
```{r warning = FALSE, message = FALSE}
  ggplot(aes(x = ApplicantIncome, y = CoapplicantIncome, color = Self_Employed)) +
  geom_point(alpha = 0.6) + 
  labs(
    title = "Zależność między dochodem wnioskodawcy a dochodem współwnioskodawcy według statusu zatrudnienia", 
    x = "Dochód wnioskodawcy",       
    y = "Dochód współwnioskodawcy",  
    color = "Samozatrudniony"       
  ) +
  theme_minimal() 
```
### Zadanie 8
Dla par zmiennych ApplicantIncome, LoanAmount zrób wykres rozrzutu. Niech zmienna Married będzie tworzyła serie. Dodał tytuł, opis osi, legendę.

```{r warning = FALSE, message = FALSE}
ggplot(data = (loan_data %>% filter(is.na(Married) == FALSE)),
       mapping = aes(x = ApplicantIncome, y = LoanAmount, color = Married),
       na_rm = TRUE
       ) +
  geom_point(mapping = aes(color = Married)) +
  labs(
    title = "Wykres rozrzutu LoanAmount w zal. od Applicant Income",
    subtitle = "w podziale na stan cywilny",
    x = "Applicant Income",
    y = "Loan Amount",
    color = "Married"
  ) +
  theme_minimal()

```

### Zadanie 9
#### Budowa 95% przedziałów ufności dla średniej i wariancji

Zbuduj 95% przedział ufności dla średniej i wariancji dla zmiennych ApplicantIncome, LoanAmount osobno dla kobiet i mężczyzn.

```{r confidence_intervals, warning = FALSE, message = FALSE}
# Inicjalizacja pustej ramki danych do przechowywania wyników
confidence_intervals_df <- data.frame(
  Zmienna = character(),
  Grupa = character(),
  Typ_Przedzialu = character(),
  Dolna_Granica = numeric(),
  Gorna_Granica = numeric(),
  stringsAsFactors = FALSE
)

# Funkcja pomocnicza do dodawania wierszy do ramki danych
add_interval_row <- function(df, variable, group, interval_type, lower, upper) {
  rbind(df, data.frame(
    Zmienna = variable,
    Grupa = group,
    Typ_Przedzialu = interval_type,
    Dolna_Granica = lower,
    Gorna_Granica = upper,
    stringsAsFactors = FALSE
  ))
}

alpha <- 0.05 

# --- Dla ApplicantIncome ---
# Kobiety
income_female <- loan_data$ApplicantIncome[loan_data$Gender == "Female"]
cat(sprintf("\nApplicantIncome - Kobiety: Liczba obserwacji = %d\n", length(income_female)))
if (length(income_female) >= 2) {
  t_test_female_income <- t.test(income_female, conf.level = 0.95)
  confidence_intervals_df <- add_interval_row(confidence_intervals_df,
                                              "ApplicantIncome", "Kobiety", "Średnia",
                                              t_test_female_income$conf.int[1], t_test_female_income$conf.int[2])

  chi_sq_var_female_income <- var(income_female, na.rm = TRUE)
  n_female_income <- length(na.omit(income_female))
  lower_var_female_income <- ((n_female_income - 1) * chi_sq_var_female_income) / qchisq(1 - alpha/2, df = n_female_income - 1)
  upper_var_female_income <- ((n_female_income - 1) * chi_sq_var_female_income) / qchisq(alpha/2, df = n_female_income - 1)
  confidence_intervals_df <- add_interval_row(confidence_intervals_df,
                                              "ApplicantIncome", "Kobiety", "Wariancja",
                                              lower_var_female_income, upper_var_female_income)
} else {
  cat("Brak wystarczającej liczby obserwacji dla ApplicantIncome - Kobiet do obliczenia przedziałów ufności.\n")
}

# Mężczyźni
income_male <- loan_data$ApplicantIncome[loan_data$Gender == "Male"]
cat(sprintf("ApplicantIncome - Mężczyźni: Liczba obserwacji = %d\n", length(income_male)))
if (length(income_male) >= 2) {
  t_test_male_income <- t.test(income_male, conf.level = 0.95)
  confidence_intervals_df <- add_interval_row(confidence_intervals_df,
                                              "ApplicantIncome", "Mężczyźni", "Średnia",
                                              t_test_male_income$conf.int[1], t_test_male_income$conf.int[2])

  chi_sq_var_male_income <- var(income_male, na.rm = TRUE)
  n_male_income <- length(na.omit(income_male))
  lower_var_male_income <- ((n_male_income - 1) * chi_sq_var_male_income) / qchisq(1 - alpha/2, df = n_male_income - 1)
  upper_var_male_income <- ((n_male_income - 1) * chi_sq_var_male_income) / qchisq(alpha/2, df = n_male_income - 1)
  confidence_intervals_df <- add_interval_row(confidence_intervals_df,
                                              "ApplicantIncome", "Mężczyźni", "Wariancja",
                                              lower_var_male_income, upper_var_male_income)
} else {
  cat("Brak wystarczającej liczby obserwacji dla ApplicantIncome - Mężczyzn do obliczenia przedziałów ufności.\n")
}

# --- Dla LoanAmount ---
# Kobiety
loanamount_female <- loan_data$LoanAmount[loan_data$Gender == "Female"]
cat(sprintf("\nLoanAmount - Kobiety: Liczba obserwacji = %d\n", length(loanamount_female)))
if (length(loanamount_female) >= 2) {
  t_test_female_loanamount <- t.test(loanamount_female, conf.level = 0.95)
  confidence_intervals_df <- add_interval_row(confidence_intervals_df,
                                              "LoanAmount", "Kobiety", "Średnia",
                                              t_test_female_loanamount$conf.int[1], t_test_female_loanamount$conf.int[2])

  chi_sq_var_female_loanamount <- var(loanamount_female, na.rm = TRUE)
  n_female_loanamount <- length(na.omit(loanamount_female))
  lower_var_female_loanamount <- ((n_female_loanamount - 1) * chi_sq_var_female_loanamount) / qchisq(1 - alpha/2, df = n_female_loanamount - 1)
  upper_var_female_loanamount <- ((n_female_loanamount - 1) * chi_sq_var_female_loanamount) / qchisq(alpha/2, df = n_female_loanamount - 1)
  confidence_intervals_df <- add_interval_row(confidence_intervals_df,
                                              "LoanAmount", "Kobiety", "Wariancja",
                                              lower_var_female_loanamount, upper_var_female_loanamount)
} else {
  cat("Brak wystarczającej liczby obserwacji dla LoanAmount - Kobiet do obliczenia przedziałów ufności.\n")
}

# Mężczyźni
loanamount_male <- loan_data$LoanAmount[loan_data$Gender == "Male"]
cat(sprintf("LoanAmount - Mężczyźni: Liczba obserwacji = %d\n", length(loanamount_male)))
if (length(loanamount_male) >= 2) {
  t_test_male_loanamount <- t.test(loanamount_male, conf.level = 0.95)
  confidence_intervals_df <- add_interval_row(confidence_intervals_df,
                                              "LoanAmount", "Mężczyźni", "Średnia",
                                              t_test_male_loanamount$conf.int[1], t_test_male_loanamount$conf.int[2])

  chi_sq_var_male_loanamount <- var(loanamount_male, na.rm = TRUE)
  n_male_loanamount <- length(na.omit(loanamount_male))
  lower_var_male_loanamount <- ((n_male_loanamount - 1) * chi_sq_var_male_loanamount) / qchisq(1 - alpha/2, df = n_male_loanamount - 1)
  upper_var_male_loanamount <- ((n_male_loanamount - 1) * chi_sq_var_male_loanamount) / qchisq(alpha/2, df = n_male_loanamount - 1)
  confidence_intervals_df <- add_interval_row(confidence_intervals_df,
                                              "LoanAmount", "Mężczyźni", "Wariancja",
                                              lower_var_male_loanamount, upper_var_male_loanamount)
} else {
  cat("Brak wystarczającej liczby obserwacji dla LoanAmount - Mężczyzn do obliczenia przedziałów ufności.\n")
}


# Wyświetlenie tabeli wyników
if (nrow(confidence_intervals_df) > 0) {
  confidence_intervals_df %>%
    knitr::kable(
      caption = '95% Przedziały Ufności dla średniej i wariancji (według płci)',
      align = 'c',
      digits = 2,
      format.args = list(big.mark = ",")
    ) %>%
    kable_styling(
      bootstrap_options = c("striped", "responsive"),
      full_width = FALSE,
      position = "left"
    )
} else {
  cat("\nBrak wystarczającej liczby danych do wygenerowania tabeli przedziałów ufności po usunięciu brakujących wartości.\n")
}
  
```
### Zadanie 10
Sprawdź czy średni poziom zmiennej ApplicantIncome różni się pomiędzy grupą osób, które otrzymały pożyczkę i nie (zmienna Loan_status)

### Zadanie 11
Sprawdź czy wariancja zmiennej ApplicantIncome różni się pomiędzy grupą osób, które otrzymały pożyczkę i nie (zmienna Loan_status)

```{r warning = FALSE, message = FALSE}
loan_data %>% group_by(Loan_Status) %>% 
  summarise(Wariancja = var(ApplicantIncome, na.rm = TRUE)) %>% 
  knitr::kable(caption = "Wariancja ApplicantIncome", align = 'c', digits = 2, format.args = list(big.mark = ",")) %>% 
  kable_styling(bootstrap_options = c("striped", "responsive"), full_width = FALSE, position = "left")
```

### Zdanie 12 Model
```{r warning = FALSE, message = FALSE}
library(dplyr) # Do manipulacji danymi
library(caret) # Do walidacji krzyżowej i oceny modelu
library(MLmetrics) # Do obliczania metryk (F1_Score, Precision, Recall)

# Upewnij się, że 'data' to Twój główny zbiór danych
# Jeśli Twoja ramka danych nazywa się inaczej, zmień 'data' na odpowiednią nazwę.

# 1. Obsługa brakujących wartości (imputacja)
# Użyjemy imputacji modą dla zmiennych kategorycznych i medianą dla numerycznych.

# Zmienne kategoryczne do imputacji modą
cat_vars_to_impute <- c("Gender", "Married", "Dependents", "Self_Employed", "Loan_Amount_Term", "Credit_History")
for (var in cat_vars_to_impute) {
  if (var %in% names(data)) {
    mode_val <- names(sort(table(data[[var]]), decreasing = TRUE))[1]
    data[[var]][is.na(data[[var]])] <- mode_val
  }
}

# Zmienne numeryczne do imputacji medianą
num_vars_to_impute <- c("LoanAmount", "ApplicantIncome", "CoapplicantIncome") # Credit_History już obsłużone jako kat
for (var in num_vars_to_impute) {
  if (var %in% names(data)) {
    median_val <- median(data[[var]], na.rm = TRUE)
    data[[var]][is.na(data[[var]])] <- median_val
  }
}

# Sprawdzenie brakujących wartości po imputacji
# sum(is.na(data)) # Powinno być 0

# 2. Przekształcanie zmiennych kategorycznych na czynniki (faktory)
# Ważne dla modeli, aby traktować te zmienne jako kategorie.
# Zmienna celu 'Loan_Status' również powinna być faktorem
data$Loan_Status <- as.factor(data$Loan_Status)

# Pozostałe zmienne kategoryczne
categorical_cols <- c(
  "Gender", "Married", "Dependents", "Education",
  "Self_Employed", "Property_Area", "Credit_History", "Loan_Amount_Term"
)

for (col in categorical_cols) {
  if (col %in% names(data)) {
    data[[col]] <- as.factor(data[[col]])
  }
}

# Upewnij się, że 'Dependents' ma uporządkowane poziomy lub jest prawidłowo przekształcone
# Jeśli 'Dependents' jest numeryczną reprezentacją (np. 0, 1, 2, 3+), upewnij się, że jest traktowane jako czynnik
# W przypadku "3+" lepiej jest to przekształcić na 3 dla celów numerycznych, jeśli model tego wymaga,
# ale dla czynnika może zostać jako osobny poziom.

# Jeśli 'Dependents' ma poziomy takie jak "3+", przekształćmy to na 3 dla prostoty w modelu,
# a następnie przekształcimy na faktor.
if ("Dependents" %in% names(data)) {
  data$Dependents <- as.character(data$Dependents)
  data$Dependents[data$Dependents == "3+"] <- "3"
  data$Dependents <- as.factor(data$Dependents)
}

# Zmienne do modelu (wyklucz Loan_ID, który jest tylko identyfikatorem)
# Możesz dostosować listę zmiennych w zależności od Twojego zbioru danych i analizy.
features <- setdiff(names(data), c("Loan_ID", "Loan_Status"))
```

```{r warning = FALSE, message = FALSE}
# Krok 1: Podział danych na zbiór treningowy i testowy (opcjonalnie, ale dobra praktyka)
# Walidacja krzyżowa zajmie się podziałem wewnętrznie, ale ogólny podział jest dobry do ostatecznej oceny.
set.seed(123) # Dla powtarzalności wyników
# Utwórz indeksy dla danych treningowych (np. 80%)
trainIndex <- createDataPartition(data$Loan_Status, p = .8, list = FALSE, times = 1)
data_train <- data[ trainIndex,]
data_test  <- data[-trainIndex,]

# Krok 2: Konfiguracja walidacji krzyżowej
# trainControl kontroluje parametry walidacji krzyżowej.
# method = "cv" oznacza walidację krzyżową
# number = 10 oznacza 10-krotną walidację krzyżową
# classProbs = TRUE pozwala na obliczenie prawdopodobieństw klas, użyteczne dla ROC
# summaryFunction = twoClassSummary - dla problemów klasyfikacji binarnej (wymaga klasy jako factor)
fitControl <- trainControl(
  method = "cv",
  number = 10,
  classProbs = TRUE,
  summaryFunction = twoClassSummary, # Funkcja do oceny dla klasyfikacji binarnej
  savePredictions = "final" # Zachowaj przewidywania dla każdej fałdy
)

# Krok 3: Budowa modelu regresji logistycznej z walidacją krzyżową
cat("\n### Budowa modelu regresji logistycznej z walidacją krzyżową ###\n")
# Zmienna celu 'Loan_Status' powinna być faktorem z dwoma poziomami (np. 'Y', 'N')
# Upewnij się, że poziom referencyjny jest ustawiony poprawnie, jeśli to ma znaczenie dla interpretacji
# Na przykład, jeśli 'Y' (pożyczka udzielona) jest klasą pozytywną, to ustaw factor(..., levels = c("N", "Y"))
# caret automatycznie obsługuje przekształcenie dla 'glm'

# Sprawdź poziomy Loan_Status
# levels(data_train$Loan_Status)
# Jeśli chcesz Y jako pozytywną klasę, upewnij się, że jest drugim poziomem lub obsłuż to w summaryFunction

# Model regresji logistycznej (glm - generalized linear model)
# . oznacza użycie wszystkich pozostałych zmiennych jako predyktorów
model_glm <- train(
  Loan_Status ~ .,
  data = data_train,
  method = "glm", # Określa, że używamy generalized linear model (regresja logistyczna)
  family = binomial(link = "logit"), # family = binomial z link = "logit" dla regresji logistycznej
  trControl = fitControl,
  metric = "ROC" # Metryka do optymalizacji modelu w cross-validation (np. ROC AUC)
)
```

```{r warning = FALSE, message = FALSE}
# Krok 4: Przewidywania na zbiorze testowym
cat("\n### Ocena modelu na zbiorze testowym ###\n")
predictions_glm <- predict(model_glm, newdata = data_test)

# Krok 5: Macierz pomyłek
# confusionMatrix wymaga, aby zarówno przewidywania, jak i rzeczywiste wartości były faktorami
confusion_matrix_glm <- confusionMatrix(predictions_glm, data_test$Loan_Status, positive = "Y") # Ustawiamy "Y" jako klasę pozytywną

cat("\n### Macierz Pomyłek dla Modelu Regresji Logistycznej ###\n")
print(confusion_matrix_glm)

# Krok 6: Statystyki na bazie macierzy pomyłek
# Accuracy
accuracy_glm <- confusion_matrix_glm$overall["Accuracy"]
cat(paste("\nAccuracy (Dokładność):", round(accuracy_glm, 4), "\n"))

# Precision (Precyzja)
# Precision = TP / (TP + FP)
# W confusionMatrix jest to "Pos Pred Value" (Positive Predictive Value)
precision_glm <- confusion_matrix_glm$byClass["Pos Pred Value"]
cat(paste("Precision (Precyzja):", round(precision_glm, 4), "\n"))

# Recall (Czułość / Kompletność)
# Recall = TP / (TP + FN)
# W confusionMatrix jest to "Sensitivity"
recall_glm <- confusion_matrix_glm$byClass["Sensitivity"]
cat(paste("Recall (Czułość/Kompletność):", round(recall_glm, 4), "\n"))

# F1-Score
# F1-Score = 2 * (Precision * Recall) / (Precision + Recall)
f1_score_glm <- 2 * (precision_glm * recall_glm) / (precision_glm + recall_glm)
cat(paste("F1-Score:", round(f1_score_glm, 4), "\n"))

# Metryki z walidacji krzyżowej (średnie dla wszystkich fałd)
cat("\n### Średnie metryki z walidacji krzyżowej (model_glm) ###\n")
print(model_glm$results)

```